/**
 * 热修复 Tinker配置与任务
 * */
def bakPath = file("${buildDir}/bakApk/")
ext {
    /**
     * 是否使用Tinker
     * 当你的项目处于开发调试阶段时，可以改为false
     * */
    tinkerEnabled = true

    /**
     * 基础包路径
     * */
    tinkerOldApkPath = "${bakPath}/app-debug-old.apk"

    /**
     * 基础包的mapping.txt文件路径
     * 用于辅助混淆补丁包的生成，一般在生成release版app时会使用到混淆，所以这个mapping.txt文件一般也是用于release安装包补丁的生成
     */
    tinkerApplyMappingPath = "${bakPath}/app-debug-old-mapping.txt"

    /**
     * 基础包的R.txt文件路径
     * 如果你的安装包中资源文件有改动，则需要使用该R.txt文件来辅助生成补丁包
     */
    tinkerApplyResourcePath = "${bakPath}/app-debug-old-R.txt"

    /**
     * 当使用flavor 多渠道打包时 使用，否则忽略
     * */
    tinkerBuildFlavorDirectory = "${bakPath}/flavor"
}

/**
 *
 * @return 基础包apk路径
 */
def getOldApkPath() {
    return ext.tinkerOldApkPath
}

/**
 *
 * @return 基础包apk混淆产生的mapping文件
 */
def getApplyMappingPath() {
    return  ext.tinkerApplyMappingPath
}

/**
 *
 * @return 基础包apk资源R.txt路径
 */
def getApplyResourceMappingPath() {
    return  ext.tinkerApplyResourcePath
}

/**
 * tinkerId 此处使用 versionName
 * @return
 */
def getTinkerIdValue() {
    return android.defaultConfig.versionName
}

/**
 *
 * @return 启用tinker
 */
def buildWithTinker() {
    return ext.tinkerEnabled
}


/**
 *
 * @return flavor路径
 */
def getTinkerBuildFlavorDirectory() {
    return ext.tinkerBuildFlavorDirectory
}

if (buildWithTinker()) {
    // 引用Tinker 插件
    apply plugin: 'com.tencent.tinker.patch'

    // 全局信息相关的配置项
    tinkerPatch {
        /**
         * 是否打开tinker的功能
         * */
        tinkerEnable = buildWithTinker()

        /**
         * 基准apk包的路径，必须输入，否则会报错。
         * */
        oldApk = getOldApkPath()

        /**
         * 是否忽略有风险的补丁包。这里选择不忽略，当补丁包风险时会中断编译。
         * tip：
         * gradle版本 影响 打包到主dex中的类
         * tinker需要的loader classes可能打不到maindex中，出现"Warning:ignoreWarning is false, but we found loader classes are found in old secondary dex."
         * 若minSdk>=21,可忽略
         * 若minSdk<21, 适配Android4.x, 参考https://blog.csdn.net/qq_29870299/article/details/84194002
         * */
        ignoreWarning = true

        /**
         * fix 插件bug  Warning:ignoreWarning is false, but we found loader classes are found in old secondary dex
         * issue:
         * https://github.com/Tencent/tinker/issues/1166
         * https://github.com/Tencent/tinker/issues/1084
         *
         *  allowLoaderInAnyDex = true
         *  removeLoaderForAllDex = true
         * */


        /**
         * 在运行过程中，我们需要验证基准apk包与补丁包的签名是否一致，我们是否需要为你签名。
         * */
        useSign = true

        // 编译相关的配置项
        buildConfig {

            /**
             * 可选参数；
             * 在编译新的apk时候，我们希望通过保持旧apk的proguard混淆方式，从而减少补丁包的大小。
             * 这个只是推荐设置，不设置applyMapping也不会影响任何的assemble编译。
             * */
            applyMapping = getApplyMappingPath()

            /**
             * 可选参数；
             * 我们希望通过旧apk的R.txt文件保持ResId的分配，这样不仅可以减少补丁包的大小，同时也避免由于ResId改变导致remote view异常。
             * */
            applyResourceMapping = getApplyResourceMappingPath()

            /**
             * 必要参数
             * 在运行过程中，我们需要验证基准apk包的tinkerId是否等于补丁包的tinkerId
             * 这个是决定补丁包能运行在哪些基准包上面，一般来说我们可以使用git版本号、versionName等等。
             * */
            tinkerId = getTinkerIdValue()

            /**
             * 如果我们有多个dex,编译补丁时可能会由于类的移动导致变更增多。若打开keepDexApply模式，补丁包将根据基准包的类分布来编译。
             * */
            keepDexApply = false

            /**
             * 是否使用加固模式，仅仅将变更的类合成补丁。注意，这种模式仅仅可以用于加固应用中。
             * */
            isProtectedApp = false

            /**
             * 是否支持新增非export的Activity（1.9.0版本开始才有的新功能）
             * */
            supportHotplugComponent = false
        }
        // dex相关的配置项
        dex {
            /**
             * 只能是'raw'或者'jar'。
             * 对于'raw'模式，我们将会保持输入dex的格式。
             * 对于'jar'模式，我们将会把输入dex重新压缩封装到jar。
             * 如果你的minSdkVersion小于14，你必须选择‘jar’模式，而且它更省存储空间，但是验证md5时比'raw'模式耗时。
             * 默认我们并不会去校验md5,一般情况下选择jar模式即可。
             */
            dexMode = "jar"

            /**
             * 需要处理dex路径，支持*、?通配符，必须使用'/'分割。路径是相对安装包的，例如assets/...
             */
            pattern = ["classes*.dex", "assets/secondary-dex-?.jar"]

            /**
             * 这一项非常重要，它定义了哪些类在加载补丁包的时候会用到。
             * 这些类是通过Tinker无法修改的类，也是一定要放在main dex的类。
             * 这里需要定义的类有：
             * 1. 你自己定义的Application类；
             * 2. Tinker库中用于加载补丁包的部分类，即com.tencent.tinker.loader.*；
             * 3. 如果你自定义了TinkerLoader，需要将它以及它引用的所有类也加入loader中；
             * 4. 其他一些你不希望被更改的类，例如Sample中的BaseBuildInfo类。这里需要注意的是，这些类的直接引用类也需要加入到loader中。或者你需要将这个类变成非preverify。
             * 5. 使用1.7.6版本之后版本，参数1、2会自动填写。
             *
             */

            loader = [

            ]
        }
        // 	lib相关的配置项
        lib {

            /**
             * 需要处理lib路径，支持*、?通配符，必须使用'/'分割。与dex.pattern一致, 路径是相对安装包的，例如assets/...
             * */
            pattern = ["lib/*/*.so", "src/main/jniLibs/*/*.so"]
        }
        // res相关的配置项
        res {
            /**
             * 需要处理res路径，支持*、?通配符，必须使用'/'分割。
             * 与dex.pattern一致, 路径是相对安装包的，例如assets/...，
             * 务必注意的是，只有满足pattern的资源才会放到合成后的资源包。
             * */
            pattern = ["res/*", "assets/*", "resources.arsc", "AndroidManifest.xml"]
            /**
             * 支持*、?通配符，必须使用'/'分割。
             * 若满足ignoreChange的pattern，在编译时会忽略该文件的新增、删除与修改。
             * 最极端的情况，ignoreChange与上面的pattern一致，即会完全忽略所有资源的修改。
             * news:指定需要忽略热修复功能的资源，此处为了不特殊处理渠道文件，所以忽略了assets目录下的文件
             * */
            ignoreChange = [
                    "assets/sample_meta.txt"
            ]

            /**
             * 对于修改的资源，如果大于largeModSize，我们将使用bsdiff算法。
             * 这可以降低补丁包的大小，但是会增加合成时的复杂度。默认大小为100kb
             * */
            largeModSize = 100
        }

        // 用于生成补丁包中的'package_meta.txt'文件
        packageConfig {
            /**
             * 默认我们自动从基准安装包与新安装包的Manifest中读取tinkerId
             * 在这里，你可以定义其他的信息，在运行时可以通过TinkerLoadResult.getPackageConfigByName得到相应的数值
             * 但是建议直接通过修改代码来实现，例如BuildConfig。
             *
             * 这里只是一个例子：
             * 你可以使用如sdkversion，brand，channel 等
             * 您可以在samplePatchListener中分析它。然后你可以有条件的使用补丁
             *
             * ShareTinkerInternals.fastGetPatchPackageMeta 可直接获取patch包里的信息
             * SamplePatchListener.patchCheck实现有条件的使用补丁
             * */

            configField("platform", "all")
            configField("sdkversion", "16")
            configField("brand", "")
            configField("channel", "")
        }
        // 7zip路径配置项，执行前提是useSign为true
        sevenZip {
            zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
        }
    }
    // 获取所有flavors
    List<String> flavors = new ArrayList<>();
    project.android.productFlavors.each { flavor ->
        flavors.add(flavor.name)
    }
    boolean hasFlavors = flavors.size() > 0
    def date = new Date().format("yyyyMMdd-HHmmss")

    /**
     * bak apk and mapping
     * 备份 apk，mapping，和R文件
     */
    android.applicationVariants.all { variant ->
        /**
         * task type, you want to bak
         */
        def taskName = variant.name
        // 返回 project所有tasks
        tasks.all {
            if ("assemble${taskName.capitalize()}".equalsIgnoreCase(it.name)) {

                it.doLast {
                    // copy
                    copy {
                        def fileNamePrefix = "${project.name}-${variant.baseName}"
                        def newFileNamePrefix = hasFlavors ? "${fileNamePrefix}" : "${fileNamePrefix}-${date}"

                        def destPath = hasFlavors ? file("${bakPath}/${project.name}-${date}/${variant.flavorName}") : bakPath
                        // 拷贝 apk
                        from variant.outputs.first().outputFile
                        into destPath
                        rename { String fileName ->
                            fileName.replace("${fileNamePrefix}.apk", "${newFileNamePrefix}.apk")
                        }

                        // 拷贝 mapping.txt
                        from "${buildDir}/outputs/mapping/${variant.dirName}/mapping.txt"
                        into destPath
                        rename { String fileName ->
                            fileName.replace("mapping.txt", "${newFileNamePrefix}-mapping.txt")
                        }

                        // 拷贝 R.txt
                        from "${buildDir}/intermediates/symbols/${variant.dirName}/R.txt"
                        into destPath
                        rename { String fileName ->
                            fileName.replace("R.txt", "${newFileNamePrefix}-R.txt")
                        }
                    }
                }
            }
        }
    }
    project.afterEvaluate {
        // 假如 有flavors 的处理例子
        if (hasFlavors) {
            task(tinkerPatchAllFlavorRelease) {
                group = 'tinker'
                def originOldPath = getTinkerBuildFlavorDirectory()
                for (String flavor : flavors) {
                    def tinkerTask = tasks.getByName("tinkerPatch${flavor.capitalize()}Release")
                    dependsOn tinkerTask
                    def preAssembleTask = tasks.getByName("process${flavor.capitalize()}ReleaseManifest")
                    preAssembleTask.doFirst {
                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 15)
                        project.tinkerPatch.oldApk = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release.apk"
                        project.tinkerPatch.buildConfig.applyMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-mapping.txt"
                        project.tinkerPatch.buildConfig.applyResourceMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-R.txt"

                    }

                }
            }

            task(tinkerPatchAllFlavorDebug) {
                group = 'tinker'
                def originOldPath = getTinkerBuildFlavorDirectory()
                for (String flavor : flavors) {
                    def tinkerTask = tasks.getByName("tinkerPatch${flavor.capitalize()}Debug")
                    dependsOn tinkerTask
                    def preAssembleTask = tasks.getByName("process${flavor.capitalize()}DebugManifest")
                    preAssembleTask.doFirst {
                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 13)
                        project.tinkerPatch.oldApk = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug.apk"
                        project.tinkerPatch.buildConfig.applyMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-mapping.txt"
                        project.tinkerPatch.buildConfig.applyResourceMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-R.txt"
                    }

                }
            }
        }
    }
}





